// üå¨Ô∏è Breathing App - Vers√£o Simples e Sem Bugs
class BreathingApp {
    constructor() {
        // Estados b√°sicos
        this.selectedRounds = 0;
        this.currentRound = 1;
        this.currentBreath = 1;
        this.sessionPhase = 'selection'; // selection, breathing, holding, recovery, complete
        this.isRunning = false;
        this.isPaused = false;
        
        // Configura√ß√µes
        this.breathsPerRound = 30;
        this.breathDuration = 3550; // 3.55 segundos
        
        // Timers
        this.breathTimer = null;
        this.holdTimer = null;
        this.recoveryTimer = null;
        
        // Dados da sess√£o
        this.holdStartTime = null;
        this.recoveryStartTime = null;
        this.currentHoldTime = 0;
        this.currentRecoveryTime = 0;
        this.roundTimes = []; // Array para armazenar {round, holdTime, recoveryTime}
        
        // Backend
        this.apiUrl = 'http://localhost:8000/api';
        this.sessionId = null;
        
        this.init();
    }

    init() {
        console.log('üöÄ Breathing App iniciado');
        this.setupEventListeners();
        this.showScreen('round-selection');
    }

    setupEventListeners() {
        // Sele√ß√£o de rounds
        document.querySelectorAll('.round-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const rounds = parseInt(e.target.dataset.rounds);
                this.selectRounds(rounds);
            });
        });

        // Bot√£o iniciar
        document.getElementById('start-btn').addEventListener('click', () => {
            this.startSession();
        });

        // Controles da sess√£o
        document.getElementById('pause-btn').addEventListener('click', () => {
            this.togglePause();
        });

        document.getElementById('stop-btn').addEventListener('click', () => {
            this.stopSession();
        });

        document.getElementById('breathe-btn').addEventListener('click', () => {
            this.endHold();
        });

        document.getElementById('release-btn').addEventListener('click', () => {
            this.endRecovery();
        });
        
        document.getElementById('new-session-btn').addEventListener('click', () => {
            this.resetToStart();
        });
    }

    selectRounds(rounds) {
        this.selectedRounds = rounds;
        
        // Atualizar visual
        document.querySelectorAll('.round-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        document.querySelector(`[data-rounds="${rounds}"]`).classList.add('selected');
        
        // Habilitar bot√£o
        document.getElementById('start-btn').disabled = false;
        
        console.log(`Rounds selecionados: ${rounds}`);
    }

    async startSession() {
        console.log(`üéØ INICIANDO SESS√ÉO: ${this.selectedRounds} rounds`);
        console.log(`üìã Estado inicial: Round ${this.currentRound} de ${this.selectedRounds}`);
        
        // Resetar estados
        this.currentRound = 1;
        this.currentBreath = 1;
        this.sessionPhase = 'breathing';
        this.isRunning = true;
        this.roundTimes = [];
        this.currentHoldTime = 0;
        this.currentRecoveryTime = 0;
        
        console.log(`‚úÖ Estados resetados: Round ${this.currentRound}, Rounds selecionados: ${this.selectedRounds}`);
        
        // Criar sess√£o no backend (opcional)
        try {
            const response = await fetch(`${this.apiUrl}/sessions/`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    rounds: this.selectedRounds,
                    breaths_per_round: this.breathsPerRound,
                    breath_duration: this.breathDuration / 1000
                })
            });
            const data = await response.json();
            this.sessionId = data.id;
            console.log('‚úÖ Sess√£o criada no backend:', data.id);
        } catch (error) {
            console.log('üîÑ Modo offline');
        }
        
        // Ir para tela de respira√ß√£o
        this.showScreen('breathing-screen');
        this.updateDisplay();
        this.startBreathingCycle();
    }

    startBreathingCycle() {
        if (!this.isRunning || this.isPaused) return;
        
        console.log(`üí® Respira√ß√£o ${this.currentBreath}/${this.breathsPerRound} - Round ${this.currentRound}`);
        
        // Atualizar display
        this.updateDisplay();
        
        // Anima√ß√£o de inspira√ß√£o
        const circleStack = document.querySelector('.circle-stack');
        circleStack.classList.remove('exhale');
        circleStack.classList.add('inhale');
        
        // Meio do ciclo - expira√ß√£o
        setTimeout(() => {
            if (!this.isRunning || this.isPaused) return;
            circleStack.classList.remove('inhale');
            circleStack.classList.add('exhale');
        }, this.breathDuration / 2);
        
        // Pr√≥xima respira√ß√£o
        this.breathTimer = setTimeout(() => {
            if (!this.isRunning || this.isPaused) return;
            
            if (this.currentBreath >= this.breathsPerRound) {
                // Round completado - iniciar hold
                this.startHoldPhase();
            } else {
                // Pr√≥xima respira√ß√£o
                this.currentBreath++;
                this.startBreathingCycle();
            }
        }, this.breathDuration);
    }

    startHoldPhase() {
        console.log(`üîµ HOLD: Iniciando reten√ß√£o Round ${this.currentRound}`);
        
        this.sessionPhase = 'holding';
        this.currentHoldTime = 0;
        this.holdStartTime = Date.now();
        
        // Atualizar interface
        this.updateDisplay();
        this.showHoldControls();
        
        // Animar c√≠rculos para modo hold
        const circleStack = document.querySelector('.circle-stack');
        circleStack.classList.remove('inhale', 'exhale');
        circleStack.classList.add('holding');
        
        // Atualizar n√∫mero no c√≠rculo
        document.getElementById('breath-number').textContent = '‚è±Ô∏è';
        
        // Iniciar cron√¥metro
        this.holdTimer = setInterval(() => {
            this.currentHoldTime = Math.floor((Date.now() - this.holdStartTime) / 1000);
            this.updateTimerDisplay();
            this.updateCircleGrowth();
        }, 1000);
    }

    updateCircleGrowth() {
        // Crescimento progressivo dos c√≠rculos baseado no tempo
        const growthFactor = Math.min(1 + (this.currentHoldTime * 0.01), 1.5);
        
        const circles = document.querySelectorAll('.circle');
        circles.forEach((circle, index) => {
            const baseScale = [1, 0.88, 0.76][index];
            const newScale = baseScale * growthFactor;
            circle.style.setProperty('--base-scale', newScale);
        });
    }

    endHold() {
        console.log(`üü¢ END HOLD: Round ${this.currentRound} - Tempo de reten√ß√£o: ${this.currentHoldTime}s`);
        
        // Parar cron√¥metro de hold
        if (this.holdTimer) {
            clearInterval(this.holdTimer);
            this.holdTimer = null;
        }
        
        // Salvar no backend (opcional)
        this.saveHoldTime();
        
        // Iniciar fase de recupera√ß√£o
        this.startRecoveryPhase();
    }

    startRecoveryPhase() {
        console.log(`ü´Å RECOVERY: Iniciando recupera√ß√£o Round ${this.currentRound}`);
        
        this.sessionPhase = 'recovery';
        this.currentRecoveryTime = 0;
        this.recoveryStartTime = Date.now();
        
        // Atualizar interface para recovery
        this.updateDisplay();
        this.showRecoveryControls();
        
        // Animar c√≠rculos para modo recovery
        const circleStack = document.querySelector('.circle-stack');
        circleStack.classList.remove('holding');
        circleStack.classList.add('recovery');
        
        // Atualizar √≠cone
        document.getElementById('breath-number').textContent = 'ü´Å';
        
        // Iniciar cron√¥metro de recovery
        this.recoveryTimer = setInterval(() => {
            this.currentRecoveryTime = Math.floor((Date.now() - this.recoveryStartTime) / 1000);
            this.updateTimerDisplay();
        }, 1000);
    }

    endRecovery() {
        console.log(`üèÅ END RECOVERY: Round ${this.currentRound} - Hold: ${this.currentHoldTime}s, Recovery: ${this.currentRecoveryTime}s`);
        
        // Parar cron√¥metro de recovery
        if (this.recoveryTimer) {
            clearInterval(this.recoveryTimer);
            this.recoveryTimer = null;
        }
        
        // Salvar tempos completos do round
        this.roundTimes.push({
            round: this.currentRound,
            holdTime: this.currentHoldTime,
            recoveryTime: this.currentRecoveryTime
        });
        
        console.log(`üìä Round ${this.currentRound} completo:`, {
            hold: this.currentHoldTime,
            recovery: this.currentRecoveryTime
        });
        
        // Verificar se √© o √∫ltimo round
        console.log(`üîç VERIFICA√á√ÉO: Round atual: ${this.currentRound}, Rounds selecionados: ${this.selectedRounds}`);
        
        if (this.currentRound >= this.selectedRounds) {
            // Sess√£o completa
            console.log(`üèÅ SESS√ÉO FINALIZADA: Completou ${this.currentRound} de ${this.selectedRounds} rounds`);
            this.completeSession();
        } else {
            // Pr√≥ximo round
            console.log(`‚û°Ô∏è CONTINUANDO: Pr√≥ximo round ${this.currentRound + 1} de ${this.selectedRounds}`);
            this.nextRound();
        }
    }

    nextRound() {
        const oldRound = this.currentRound;
        
        // Incrementar round
        this.currentRound++;
        this.currentBreath = 1;
        this.sessionPhase = 'breathing';
        
        console.log(`üöÄ PR√ìXIMO ROUND: ${oldRound} ‚Üí ${this.currentRound} (de ${this.selectedRounds} total)`);
        
        // Resetar interface
        this.hideAllControls();
        this.showBreathingControls();
        this.resetCircles();
        
        // Atualizar display
        this.updateDisplay();
        
        // Pequena pausa antes do pr√≥ximo round
        setTimeout(() => {
            if (this.isRunning) {
                console.log(`üîÑ Retomando respira√ß√£o no Round ${this.currentRound}`);
                this.startBreathingCycle();
            }
        }, 2000);
    }

    completeSession() {
        console.log('üèÅ SESS√ÉO COMPLETA');
        
        this.isRunning = false;
        this.sessionPhase = 'complete';
        
        // Limpar timers
        this.clearAllTimers();
        
        // Mostrar tela de conclus√£o
        this.showCompletionScreen();
    }

    // M√©todos de Interface
    showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        document.getElementById(screenId).classList.add('active');
    }

    updateDisplay() {
        document.getElementById('current-round').textContent = this.currentRound;
        document.getElementById('total-rounds').textContent = this.selectedRounds;
        document.getElementById('breath-number').textContent = this.currentBreath;
        
        // Atualizar contadores de respira√ß√£o
        const breathCounter = document.getElementById('breath-counter');
        if (this.sessionPhase === 'breathing') {
            breathCounter.textContent = `Respira√ß√£o ${this.currentBreath} de ${this.breathsPerRound}`;
        }
        
        // Atualizar fase
        const phaseText = document.getElementById('phase-text');
        const timerDisplay = document.getElementById('timer-display');
        
        switch (this.sessionPhase) {
            case 'breathing':
                phaseText.textContent = 'Respira√ß√£o';
                breathCounter.classList.remove('hidden');
                timerDisplay.classList.add('hidden');
                break;
            case 'holding':
                phaseText.textContent = 'Reten√ß√£o';
                breathCounter.classList.add('hidden');
                timerDisplay.classList.remove('hidden');
                break;
            case 'recovery':
                phaseText.textContent = 'Recupera√ß√£o';
                breathCounter.classList.add('hidden');
                timerDisplay.classList.remove('hidden');
                break;
        }
    }

    updateTimerDisplay() {
        let timeToShow = 0;
        
        if (this.sessionPhase === 'holding') {
            timeToShow = this.currentHoldTime;
        } else if (this.sessionPhase === 'recovery') {
            timeToShow = this.currentRecoveryTime;
        }
        
        const minutes = Math.floor(timeToShow / 60);
        const seconds = timeToShow % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        document.getElementById('timer-display').textContent = timeString;
    }

    showHoldControls() {
        this.hideAllControls();
        document.getElementById('hold-controls').classList.add('active');
        
        // Mostrar lista de tempos
        document.getElementById('round-times').classList.remove('hidden');
        this.updateRoundTimesList();
    }

    showRecoveryControls() {
        this.hideAllControls();
        document.getElementById('recovery-controls').classList.add('active');
        
        // Mostrar lista de tempos
        document.getElementById('round-times').classList.remove('hidden');
        this.updateRoundTimesList();
    }

    showBreathingControls() {
        this.hideAllControls();
        document.getElementById('breathing-controls').classList.add('active');
        
        // Esconder lista de tempos
        document.getElementById('round-times').classList.add('hidden');
    }

    hideAllControls() {
        document.getElementById('breathing-controls').classList.remove('active');
        document.getElementById('hold-controls').classList.remove('active');
        document.getElementById('recovery-controls').classList.remove('active');
    }

    resetCircles() {
        const circleStack = document.querySelector('.circle-stack');
        circleStack.classList.remove('inhale', 'exhale', 'holding', 'recovery', 'growing');
        
        // Resetar escalas
        document.querySelectorAll('.circle').forEach(circle => {
            circle.style.removeProperty('--base-scale');
        });
        
        // Resetar n√∫mero
        document.getElementById('breath-number').textContent = '1';
    }

    updateRoundTimesList() {
        const timesList = document.getElementById('times-list');
        timesList.innerHTML = '';
        
        this.roundTimes.forEach(round => {
            const holdMinutes = Math.floor(round.holdTime / 60);
            const holdSeconds = round.holdTime % 60;
            const holdString = `${holdMinutes}:${holdSeconds.toString().padStart(2, '0')}`;
            
            let recoveryString = '';
            if (round.recoveryTime > 0) {
                const recMinutes = Math.floor(round.recoveryTime / 60);
                const recSeconds = round.recoveryTime % 60;
                recoveryString = ` | Recupera√ß√£o: ${recMinutes}:${recSeconds.toString().padStart(2, '0')}`;
            }
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'round-time';
            timeDiv.textContent = `Round ${round.round}: ${holdString}${recoveryString}`;
            timesList.appendChild(timeDiv);
        });
        
        // Mostrar round atual se ainda em progresso
        if (this.sessionPhase === 'holding' || this.sessionPhase === 'recovery') {
            const currentDiv = document.createElement('div');
            currentDiv.className = 'round-time current-round';
            
            if (this.sessionPhase === 'holding') {
                const minutes = Math.floor(this.currentHoldTime / 60);
                const seconds = this.currentHoldTime % 60;
                const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                currentDiv.textContent = `Round ${this.currentRound}: ${timeString} (em progresso...)`;
            } else if (this.sessionPhase === 'recovery') {
                const holdMinutes = Math.floor(this.currentHoldTime / 60);
                const holdSeconds = this.currentHoldTime % 60;
                const holdString = `${holdMinutes}:${holdSeconds.toString().padStart(2, '0')}`;
                
                const recMinutes = Math.floor(this.currentRecoveryTime / 60);
                const recSeconds = this.currentRecoveryTime % 60;
                const recString = `${recMinutes}:${recSeconds.toString().padStart(2, '0')}`;
                
                currentDiv.textContent = `Round ${this.currentRound}: ${holdString} | Recupera√ß√£o: ${recString}`;
            }
            
            timesList.appendChild(currentDiv);
        }
    }

    showCompletionScreen() {
        this.showScreen('completion-screen');
        
        // Estat√≠sticas b√°sicas
        document.getElementById('summary-rounds').textContent = this.selectedRounds;
        document.getElementById('summary-breaths').textContent = this.selectedRounds * this.breathsPerRound;
        
        // Lista de hold times
        const holdList = document.getElementById('hold-list');
        holdList.innerHTML = '';
        
        let totalHoldTime = 0;
        
        this.roundTimes.forEach(round => {
            totalHoldTime += round.holdTime;
            
            const holdMinutes = Math.floor(round.holdTime / 60);
            const holdSeconds = round.holdTime % 60;
            const holdString = `${holdMinutes}m ${holdSeconds}s`;
            
            let recoveryString = '';
            if (round.recoveryTime > 0) {
                const recMinutes = Math.floor(round.recoveryTime / 60);
                const recSeconds = round.recoveryTime % 60;
                recoveryString = ` | Recupera√ß√£o: ${recMinutes}m ${recSeconds}s`;
            }
            
            const item = document.createElement('div');
            item.className = 'hold-time-item';
            item.innerHTML = `
                <span>Round ${round.round}:</span>
                <span class="hold-time-value">${holdString}${recoveryString}</span>
            `;
            holdList.appendChild(item);
        });
        
        // Totais
        const avgHoldTime = this.roundTimes.length > 0 ? totalHoldTime / this.roundTimes.length : 0;
        
        const totalMinutes = Math.floor(totalHoldTime / 60);
        const totalSeconds = totalHoldTime % 60;
        document.getElementById('total-hold-time').textContent = `${totalMinutes}m ${totalSeconds}s`;
        
        const avgMinutes = Math.floor(avgHoldTime / 60);
        const avgSecondsRounded = Math.round(avgHoldTime % 60);
        document.getElementById('avg-hold-time').textContent = `${avgMinutes}m ${avgSecondsRounded}s`;
    }

    // Controles
    togglePause() {
        this.isPaused = !this.isPaused;
        const pauseBtn = document.getElementById('pause-btn');
        
        if (this.isPaused) {
            pauseBtn.textContent = 'Continuar';
            this.clearAllTimers();
            console.log('‚è∏Ô∏è Pausado');
        } else {
            pauseBtn.textContent = 'Pausar';
            if (this.sessionPhase === 'breathing') {
                this.startBreathingCycle();
            } else if (this.sessionPhase === 'holding') {
                this.resumeHoldTimer();
            }
            console.log('‚ñ∂Ô∏è Retomado');
        }
    }

    resumeHoldTimer() {
        // Retomar timer de hold considerando tempo j√° passado
        this.holdStartTime = Date.now() - (this.currentHoldTime * 1000);
        this.holdTimer = setInterval(() => {
            this.currentHoldTime = Math.floor((Date.now() - this.holdStartTime) / 1000);
            this.updateTimerDisplay();
            this.updateCircleGrowth();
        }, 1000);
    }

    stopSession() {
        console.log('üõë Sess√£o parada');
        this.isRunning = false;
        this.clearAllTimers();
        this.resetToStart();
    }

    resetToStart() {
        console.log('üîÑ Reset para in√≠cio');
        
        // Resetar todos os estados
        this.selectedRounds = 0;
        this.currentRound = 1;
        this.currentBreath = 1;
        this.sessionPhase = 'selection';
        this.isRunning = false;
        this.isPaused = false;
        this.currentHoldTime = 0;
        this.currentRecoveryTime = 0;
        this.roundTimes = [];
        
        // Limpar timers
        this.clearAllTimers();
        
        // Resetar interface
        document.querySelectorAll('.round-btn').forEach(btn => {
            btn.classList.remove('selected');
        });
        document.getElementById('start-btn').disabled = true;
        document.getElementById('pause-btn').textContent = 'Pausar';
        
        this.resetCircles();
        this.showScreen('round-selection');
    }

    clearAllTimers() {
        if (this.breathTimer) {
            clearTimeout(this.breathTimer);
            this.breathTimer = null;
        }
        if (this.holdTimer) {
            clearInterval(this.holdTimer);
            this.holdTimer = null;
        }
        if (this.recoveryTimer) {
            clearInterval(this.recoveryTimer);
            this.recoveryTimer = null;
        }
    }

    // Backend (opcional)
    async saveHoldTime() {
        if (!this.sessionId) return;
        
        try {
            await fetch(`${this.apiUrl}/sessions/${this.sessionId}/end_hold/`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    round_number: this.currentRound,
                    hold_seconds: this.currentHoldTime
                })
            });
            console.log('‚úÖ Hold time salvo no backend');
        } catch (error) {
            console.log('‚ùå Erro ao salvar hold time');
        }
    }
}

// Inicializar quando p√°gina carregar
document.addEventListener('DOMContentLoaded', () => {
    window.breathingApp = new BreathingApp();
    console.log('‚úÖ App inicializado');
});
